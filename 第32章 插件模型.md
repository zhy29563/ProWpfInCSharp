# 第32章 插件模型

插件是应用程序能够动态发现、加载和使用的单独编译过的组件。通常，应将应用程序设计成能使用插件，从二科再将来进行增强，而不必进行任何修改、重新编译以及重新测试。插件还为针对特殊的时间或客户单独定制应用程序实例提供了灵活性。但使用插件模型最常见的原因是，允许第三方开发人员扩展应用程序的功能。例如，Adobe Photoshop中的插件提供了大量图像处理效果。Firefox中的插件提供给了增强的Web冲浪特性已及全新功能。对于这两种情况，插件都是由第三方开发人员创建的。

自从.NET1.0发布后，开发人员就具备了创建自己的插件系统所需要的全部技术。两个基本要素是接口（接口用于定义协定，应用程序通过协定和插件今年新给交互，并且插件也通过协定关于应用程序进行交互）和反射（通过反射，应用程序可动态地从单独的程序集中发现和加载插件类型）。然后，从头构建插件系统需要做许多工作。需要设计一种方法来定位插件，并需要确保正确地管理插件（换句话说，他们再限定的安全上下文中执行，并当必要时能够卸载）。

幸运的是，.NET提供了预先构建好的插件模型，该模型使用结构和反射，就像您可能自己编写的插件模型一样，该插件模型为许多繁琐任务（如发现和主流）提够了低级处理。

## 32.1 在MAF和MEF两者间进行选择

在开始构建使用插件的可扩展的应用陈旭之前，需要处理如下意想不到的令人头痛的问题：.NET不是仅有一个插件框架，而是有两个插框架。

.NET 3.5 引入了陈伟托管插件框架（Managed Add-in Framework, MAF）的插件模型。但使问题变得更有趣（并且更让人困惑）的是，.NET 4引入了称为托管可扩展框架（Managed Extensibility Framework, MEF）的新模型。在不久以前还必须构建自己的插件系统的开发人员，现在突然有了两种完全独立的具有相同背景的技术。那么这两种模型之前到底有什么区别呢？

MAF是这两个框架中较可靠的框架。该框架允许从应用程序中分离出插件，从而他们只依赖于您的结构定义。如果希望处理不同的版本，MAF提供了很受欢迎的灵活性——例如，如果需要修改接口，但为了向后兼容，需要继续支持旧的插件。MAF还允许应用程序将插件加载到独立的应用程序域中，从而插件的奔溃是无害的，不会涌现主应用程序。所有这些特定意味着，如果一个开发团队开发应用陈旭，另一个团队开发插件，MAF可以工作的很好。MAF还特写适于第三方插件。

但为了得到MAF功能需要付出代价。MAF是复杂的框架，并且即使是对于简单应用程序， 设置插件管道也很繁琐。这正是MEF的出发点。MEF是轻量级选择，目的是是的实现可扩展性就行是将相关的程序集复制到同一个文件夹中那样容易。但MEF相对MAF有不同的基本原则。MAF是严格的、结构驱动的插件模型，而MEF是自由使用系统，允许根据部件集合构建应用程序。每个部件导出功能，任何部件都可以导入其他部件的功能。该系统为开发人员提供给了更大灵活性，并且对于设计可组合的应用程序工作得特别好。MEF的现主危险时太松散，对于设计不良的应用程序，相互关联的部件很快变得很混乱。

## 32.2 了解插件管道

插件模型的主要优点是不需要为许多任何编写底层代码，主要缺点是插件模型非常复杂。.NET设计人员非常注重使插件模型足够灵活，以及处理各种版本和宿主情况。最终结构是，为在应用程序中实现插件模型，至少必须创建7个单独组件，那么即使不需要使用插件模型的高级功能也同样如此。

插件模型的核心是插件管道(pipeline)，它是一系列组件，这些组件允许宿主应用程序与插件进行交互。在管道的一端是宿主应用程序，另一端是插件，中间是控制交互的5个组件。

![image-20200902110250213](第32章 插件模型.assets\image-20200902110250213.png)

乍一看，这个模型看起来有点过分。更简单的情况是在应用程序和插件之间只放置单独的一层（协定）。然而，额外层（视图和适配器）使插件模型在特定情况下更灵活。

### 32.2.1 管道的工作原理

协定是插件管道的基石，提供了一个或多个接口，这写接口定义了宿主应用程序如何与插件进行交互，以及插件如何与宿主应用程序进行交互。协定程序集还可以包含自定义的计划，用于在宿主应用程序和插件之间传递数据的可串行化类型。

插件管道的设计充分考虑了可扩展性和灵活性。正是因为如此，宿主应用程序和插件不能直接使用协定。相反，他们使用各自版本的协定，称为视图。宿主应用程序使用宿主视图，而插件使用插件视图。通常，视图包含于协定中的接口紧密配合的抽象类。

尽管它们通常很类似，但协定和视图完全相互独立。适配器负责将这两部分链接在一起。适配器通过提供同事继续自视图类并协定接口的类，执行这一链接。

![image-20200902112230576](第32章 插件模型.assets\image-20200902112230576.png)

本质上，适配器桥接了视图和协定接口。它们将视图上的调用映射到协定接口的调用，还将协议接口上的调用映射到视图中的相应方法。虽然这种设计有些复杂，但添加了最重要的提供灵活性的额外层。

为理解适配器的工作原理，分析当应用程序使用插件时会发生什么情况。首先，宿主应用程序调用宿主视图中的方法。但请记住，宿主视图时抽象两。在背后，应用程序实际上通过宿主视图调用宿主适配器中的方法。然后宿主方适配器调用协定接口中的相应方法，该方法是由插件方适配器实现的。最后，插件方适配器调用插件视图中的方法。这个方法是由插件实现的，负责执行实际工作。

> 更高级的适配器
>
> 如果没有任何特殊的版本或宿主需求，适配器比较简单。他们只是沿着管道传递工作。然而，对于更复杂的情况，适配器也是重要的可扩展点。一个力资是版本问题。显然，只要在协定中继续使用相同的接口，就可独立地更新应用程序或其插件，而不需要改变他们的交互方式。然而，在某些情况下，为了提供新功能，可能需要改变接口。这会导致一些问题，原因是为了向后兼容老插件，必须支持老接口。经过几次改版后，就会得到一些类似但不同的结构，并且应用程序需要识别并支持所有接口。
>
> 使用插件模型，可用不同的方法实现向后兼容。不是提供多个接口，而是在协定中只提供一个接口，并使用适配器创建不同的视图。例如，版本1的插件可用于版本2的应用程序（该应用程序提供了版本2的协定），只要有适配器能够跨越他们之间的间隙即可。同样，如果开发了使用版本2协定的插件，就可通过使用不同的插件方适配器，在原来版本1的应用程序（以及版本1的协定）中使用该插件。
>
> 如果需要特殊宿主，可使用类似的技巧。例如，可使用适配器在不同的相互独立的层次加载插件，甚至可在应用程序之间共享它们。宿主应用程序和插件不需要知道这些细节，因为适配器处理了所有细节。

即使不需要创建定制的适配器以实现特定版本和宿主策略，也仍需要提供这些组件。然而，所有插件都能使用相同的视图和适配器组件。换句话说，一旦为插件设置完整管道，就可以添加更多插件而不必做很多工作。

### 32.2.2 插件文件夹结构

为了使用插件管道，必须遵循严格的目录结构。这个目录结构和应用程序相分离。换句话说，应用程序位于一个位置，而所有插件和管道组件位于另外一个位置是完全可以的。然而，插件组件必须被安排到使用特定名称的子目录中。例如，如果插件系统使用的根目录为`C:\\MyApp`，就需要以下子目录：

> C:\\MyApp\\AddInSideAdapters
> C:\\MyApp\\AddInViews
> C:\\MyApp\\Contracts
> C:\\MyApp\\HostSideAdapters
> C:\\MyApp\\AddIns

最后，AddIns目录必须为应用程序使用的每个插件提供给单独的子目录，如：

> C:\\MyApp\\AddIns\\MyFirstAddIn
>
> C:\\MyApp\\AddIns\\MySecondAddIn

在这个示例中，假定可执行的应用程序被部署到C:\\MyApp子目录中。换句话说，同一个文件夹既作为应用程序文件夹，又作为插件的根目录。这是常见的部署选择，但并非必须如此。

> 注意：
>
> 如果已经仔细查看过管道图形，您可能已经注意到为每个组件都提供了子目录，只有宿主方视图例外。这是因为宿主方视图直接由宿主应用程序使用，所以他们和可执行的应用程序一同部署。不能以相同当时部署插件视图，因为几个插件可能使用相同的插件视图。幸亏有了专门的AddInViews文件夹，我们只需要部署并更新每个视图程序集的副本即可。

### 32.2.3 为使用插件模型准备解决方案

插件文佳佳结构是必须的。如果遗漏前面列出的某个子文件夹，当查找插件时将遇到运行时异常。下面是最简单的方法：

- 创建包含即将传概念的所有项目的顶级目录。例如，可将这个目录命名为C:\\MyAppTest
- 在该目录中为宿主应用程序新建WPF项目。如何命名没有关系，但必须将它放置到上一步骤创建的顶级目录中
- 为每个管道组件添加新的类库项目，并将他们放到同一个解决方案中。至少，需要为插件创建项目，为视图创建项目，为插件方适配器创建项目，为宿主视图创建项目，为苏住房适配器创建项目。
- 现在徐娅在顶级目录中创建生成目录。当编译时，这是放置应用程序和所有管道组件的地方。通常键更改目录命名为Output
- 当设计各种管道组件时，需要修改每个组件项目的生成路径。使组件能放到正确的子目录中。





## 32.3 创建使用插件模型的应用程序



为应用程序定义插件管道的开始点使创建协定程序集。协定程序集定义了如下两项内容：

- 定义宿主将如何与插件进行交互，以及插件如何与宿主进行交互的接口
- 用于在宿主和插件之间交换信息的自定义类型。这些类型必须是可串行化的

本例使用的协定飞铲更简单。插件提供名为ProcessImageBytes()的方法，该方法接受包含图像数据的字节数组，然后修改该数组，并返回修改后的字节数组。下面是定义该方法的协定：

```c#
[System.AddIn.Pipeline.AddInContract]
public interface IImageProcessorContract : System.AddIn.Contract.IContract
{
byte[] ProcessImageBytes(byte[] pixels);
}
```

当创建协定时，必须继承自IContract接口，并且必须使用AddInContract特性修饰协定类。这些都被包含于System.AddIn.Contract.dll中。

因为图像处理示例中没有使用滴定仪类型传递数据（而使用普通的字节数组），所以在协定程序集中没有定义类型。可在宿主应用程序和插件之间传递字节数组，因为字节和数组都是可串行化的。

唯一需要的额外步骤时配置生成目录。必须将协定程序集放在插件根目录的Contracts子目录中，这意味着在当前示例中，需要将协定程序集的输出路径设置为"../Output/contracts"。



### 32.3.2 插件视图

插件视图提供了镜像协定程序集的抽象类，并被用于插件一方。创建这个类很容易，如下所示：

```c#
[System.AddIn.Pipeline.AddInBase]
public abstract class ImageProcessorAddInView
{
    public abstract byte[] ProcessImageBytes(byte[] pixels);
}
```

注意，必须使用AddInBase特性修饰插件视图类。必须将插件视图程序放到插件根目录的AddInViews子目录中。

### 32.3.3 插件

插件视图时未提供任何功能的抽象类。为创建可供使用的插件，需要使用继承自抽象视图的具体类。

```c#
[System.AddIn.AddIn("Negative Image Processor", Version = "1.0.0.0", Publisher = "Imaginomics", Description = "Inverts colors to look like a photo negative")]
public class NegativeImageProcessor : AddInView.ImageProcessorAddInView 
{
    public override byte[] ProcessImageBytes(byte[] pixels)
    {
        for (int i = 0; i < pixels.Length - 2; i++)
        {
            pixels[i] = (byte)(255 - pixels[i]);
            pixels[i + 1] = (byte)(255 - pixels[i + 1]);
            pixels[i + 2] = (byte)(255 - pixels[i + 2]);
        }
        return pixels;
    }
}
```

为创建插件，只需要创建抽象的视图类的派生类，并使用AddIn特性修饰该类即可。此外，还可以使用AddIn特性修饰该类即可。此外，还可以使用AddIn特性的属性提供插件的名称、版本、发布者以及说明信息。在发现插件期间，宿主可获取这些信息。

插件程序需要两个引用：对System.AddIn.dll程序集的引用和对插件视图项目的引用。然而，必须将插件视图引用的Copy Local属性设置为false。这是因为插件视图不能和插件部署在一起，而应放到指定的AddInViews子目录中。插件必须放到它自己的子目录中，这个子目录位于插件根目录的AddIns子目录。

### 32.3.4 插件适配器

当前实例具备了所需要的所有插件功能，但在插件和协定之间仍然存在着距离。尽管插件视图时根据协定构建的，但却没有实现用于在应用程序和插件之间进行通信的协定接口。

缺少的要素是插件适配器。插件适配器实现了协定接口。当调用协定接口中的方法时，插件适配器会调用插件视图中的相应方法。

```c#
[System.AddIn.Pipeline.AddInAdapter]
public class ImageProcessorViewToContractAdapter : System.AddIn.Pipeline.ContractBase, Contract.IImageProcessorContract
{
    private readonly AddInView.ImageProcessorAddInView view;

    public ImageProcessorViewToContractAdapter(AddInView.ImageProcessorAddInView view)
    {
        this.view = view;
    }

    public byte[] ProcessImageBytes(byte[] pixels)
    {
        return view.ProcessImageBytes(pixels);
    }
}
```

所有插件适配器都必须继承自ContractBase类。该类又继承自MarchalByRefObject类，这样就能够跨越应用程序域边界调用适配器。所有插件方适配器还必须使用AddInAdapter特性修饰。外此，插件适配器必须提供接受恰当视图类的实例作为参数的构造函数。当插件基础架构创建插件适配器时，会地洞使用这个构造函数并传入插件本身。代码只是需要保存这个视图以备以后使用。

### 32.3.5 宿主视图

下一步是构建插件官当的宿主方。宿主域宿主视图尽心给交互。与插件视图一样，宿主视图时紧密镜像协定结构的抽象类。唯一的区别时不需要任何特性。

```c#
public abstract class ImageProcessorHostView
{
    public abstract byte[] ProcessImageBytes(byte[] pixels);
}
```

### 32.3.6 宿主适配器

宿主方适配器集成自宿主视图。它接受一个试下了协定的对象，然后当调用宿主方适配器的方法时使用该对象。这个前面插件方适配器使用的转发过程时相同的，但方向相反。在这个实例中，方宿主应用程序调用宿主视图的ProcessImageBytes()方法时，它实际上调用的是宿主方适配器对应的方法。

```c#
[System.AddIn.Pipeline.HostAdapter]
public class ImageProcessorContractToViewHostAdapter : HostView.ImageProcessorHostView
{
    private Contract.IImageProcessorContract contract;
    private System.AddIn.Pipeline.ContractHandle contractHandle;

    public ImageProcessorContractToViewHostAdapter(Contract.IImageProcessorContract contract)
    {            
        this.contract = contract;
        contractHandle = new System.AddIn.Pipeline.ContractHandle(contract);
    }              

    public override byte[] ProcessImageBytes(byte[] pixels)
    {
        return contract.ProcessImageBytes(pixels);
    }
}
```

您可能主要到，宿主方适配器实际上使用了两个成员字段。它保存了当前协定对象的引用，以及System.AddIn.Pipeline.ContractHandle对象的引用。System.AddIn.Pipeline.ContractHandle对象管理插件的生命周期。如果宿主方适配器没有创建ContractHandle对象，在构造函数代码执行完毕之后会自立释放插件。当宿主应用程序视图使用插件时，会收到AppDomainUnloadedException异常。

### 32.3.7 宿主

宿主只需要只想宿主视图项目的引用。宿主视图是插件的管道的入口点。实际上，现在已经实现了插件管道的主要内容，宿主不必担心如何管理插件管道。只需要查找可用的插件，激活希望使用的插件，然后调用由宿主视图提供的方法即可。